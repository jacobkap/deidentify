
<!-- README.md is generated from README.Rmd. Please edit that file -->

# De-identify private data

<!-- badges: start -->

[![Travis build
status](https://travis-ci.org/jacobkap/deidentify.svg?branch=master)](https://travis-ci.org/jacobkap/deidentify)
[![AppVeyor build
status](https://ci.appveyor.com/api/projects/status/github/jacobkap/deidentify?branch=master&svg=true)](https://ci.appveyor.com/project/jacobkap/deidentify)
[![CRAN
status](https://www.r-pkg.org/badges/version/deidentify)](https://CRAN.R-project.org/package=deidentify)
[![Lifecycle:
experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![Codecov test
coverage](https://codecov.io/gh/jacobkap/deidentify/branch/master/graph/badge.svg)](https://codecov.io/gh/jacobkap/deidentify?branch=master)
[![](http://cranlogs.r-pkg.org/badges/grand-total/deidentify?color=blue)](https://cran.r-project.org/package=deidentify)
<!-- badges: end -->

The goal of `deidentify` is to automate some of the work of
de-identifying private data for releasing that data to the public. This
involves determining how many people are in each unique group (the “case
score”) which determines how easy it is to figure out who someone is.
Basically, if someone meets a criteria that is rare in your data
(e.g. combination of some columns such as a White female, who lives in
X city, and is aged 16) then it could be easier to figure out who it is.
The `deidentify_data()` function helps to de-identify data by
aggregating values that are rare, encrypting strings (though the
`seed_cipher()` function in the `caesar` package), and aggregating dates
in larger groupings (e.g. months, years)

## Installation

Currently, deidentify is only available on
[GitHub](https://github.com/). To install the dev version then, you can
use the following

``` r
# install.packages("devtools")
devtools::install_github("jacobkap/deidentify")
```

## Applying the

deidentify builds off of [caesar](https://github.com/jacobkap/caesar) to
encrypt strings. In doing so, deidentify applies a seed cipher to the
data. In its most straightforward application, it can be used to apply
the cipher to a column with character or numeric values. To do so, one
could implement the following:

``` r
library(deidentify)
# example data
example_data <- data.frame(name = c("cat", "dog", "puppy", "puppy"), month = c("2020-01-01", 
    "2020-02-21", "2020-03-28", "2020-04-15"))
# running the command.
x_data <- deidentify_data(example_data, cols_to_encrpyt = "name", seeds_for_encryption = 1e+08)
#> [1] "Below are the columns that you encrypted and the seed set for each column. Please keep a record of this so you can decrypt later."
#>  1e+08 
#> "name"
```

From the above, you will find that deidentify prints a message regarding
the names of the columns you chose to encrypt as well as the seed which
either the user provided or was autogenerated by the function. If you
choose not to supply your own seed, ensure that you write it down in
order to be able to decrypt in the future.

If you want to encrypt 2 or more columns, you can pass the names of the
columns as a character vector to the cols\_to\_encrypt parameter as
follows.

``` r
new_col <- c("10102","10203","10902","10991")
new_data <- cbind(example_data,new_col)
deidentify_data(new_data,cols_to_encrpyt = c("name","new_col"))
#> [1] "Below are the columns that you encrypted and the seed set for each column. Please keep a record of this so you can decrypt later."
#>   3646797    170902 
#>    "name" "new_col"
#>    name      month new_col
#> 1   sg8 2020-01-01    Q QP
#> 2   ONW 2020-02-21    QPQ8
#> 3 F'FF` 2020-03-28    QIQP
#> 4 F'FF` 2020-04-15    QII
```

While the above should give you a sense on how to use deidentify, there
are more features which can be used. These are covered more in depth in
the vignettes for the package.
